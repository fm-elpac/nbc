//! 编译器前端和后端共享的数据结构
//!
//! 抽象语法树 (AST)

mod ast;
mod dt;

pub use ast::{
    语法树, 语法树代码块, 语法树函数, 语法树函数调用, 语法树分支, 语法树包装, 语法树匹配,
    语法树变量, 语法树字面量, 语法树导入, 语法树导入方式, 语法树导出, 语法树循环, 语法树循环模式,
    语法树循环范围, 语法树数字, 语法树数字格式, 语法树文本, 语法树破, 语法树类型, 语法树类型类型,
    语法树表达式, 语法树访问成员, 语法树语句, 语法树赋值语句, 语法树返回,
};
pub use dt::{数据类型, 数据类型内置, 数据类型定义, 数据类型定义类型};

/// 一个源文件的信息
#[derive(Debug, Clone)]
pub struct 源文件 {
    /// 每个源文件都会分配一个唯一编号 (在一次编译中)
    pub 编号: u64,
    /// 源文件的存储路径 (PATH)
    pub 路径: String,
    /// 源文件内容的哈希值
    pub 哈希: String,
}

impl Default for 源文件 {
    fn default() -> Self {
        Self {
            编号: 0,
            路径: "".into(),
            哈希: "".into(),
        }
    }
}

/// 一个模块: 一个源文件对应一个模块
#[derive(Debug, Clone)]
pub struct 模块 {
    /// 对应的包编号
    pub 包号: u64,
    /// 对应的源文件
    pub 文件: 源文件,
    /// 抽象语法树
    pub 内容: Box<语法树>,
}

/// 标记语法: 一个标记
#[derive(Debug, Clone, PartialEq)]
pub enum 标记 {
    /// `标记内部`
    内部,
    /// `标记自动类型转换`
    自动类型转换,
    /// `标记运算符`
    运算符,
    /// `标记前运算符`
    前运算符,
    /// `标记后运算符`
    后运算符,
    /// `标记严格数学`
    严格数学,
}

/// 源代码位置信息: 用于调试
#[derive(Debug, Clone)]
pub struct 源代码位置 {
    /// 源文件对应的唯一编号
    pub 编号: u64,
    /// 开始位置: (行号, 列号)
    pub 开始: (u32, u32),
    /// 结束位置: (行号, 列号)
    pub 结束: (u32, u32),
}

impl Default for 源代码位置 {
    fn default() -> Self {
        Self {
            编号: 0,
            开始: (0, 0),
            结束: (0, 0),
        }
    }
}
