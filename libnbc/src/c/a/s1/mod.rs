//! 编译器前端第 1 阶段: 词法分析 (token)

use super::super::c::{
    最大缩进长度, 特殊字符0, 特殊字符9, 特殊字符A, 特殊字符F, 特殊字符N, 特殊字符X, 特殊字符_O,
    特殊字符下划线, 特殊字符中括号右, 特殊字符中括号左, 特殊字符冒号, 特殊字符减, 特殊字符反引号,
    特殊字符句号, 特殊字符大括号右, 特殊字符大括号左, 特殊字符小括号右, 特殊字符小括号左,
    特殊字符引号, 特殊字符换行, 特殊字符注释, 特殊字符点, 特殊字符空格, 特殊字符转义, 特殊字符逗号,
    特殊字符顿号,
};
use super::super::e::{ne0003, ne0004, ne0006, ne0007, ne0008, 编译器错误};
use super::super::t::{源代码位置, 源文件, 语法树数字格式};
use super::t::{编译前端设置, 语词, 语词类型};

/// 词法分析器的当前状态
#[derive(Debug, Clone, PartialEq)]
enum 分析状态 {
    /// 初始状态
    初始,
    /// 注释
    注释,
    /// 空白
    空白,
    /// 行首缩进
    缩进,
    /// 字符串: 非插值部分
    字符串,
    /// 字符串: 遇到转义字符 `\\`
    字符串转义,
    /// 字符串: 插值部分
    字符串插值,
    /// 字面量: 数字
    数字,
    /// 待分词 (普通短语)
    待分词,
    /// 已分词 (禁止分词)
    已分词,
}

/// 进行词法分析 (token)
#[derive(Debug, Clone)]
pub struct 词法分析器 {
    文件: 源文件,
    位置: 源代码位置,

    状态: 分析状态,
    // 要输出的结果
    输出: Vec<语词>,

    // 当前缓存的字符
    缓存: Vec<char>,
}

impl 词法分析器 {
    pub fn new(_设置: 编译前端设置, 文件: 源文件) -> Self {
        Self {
            文件: 文件.clone(),
            位置: 源代码位置 {
                编号: 文件.编号,
                开始: (1, 1),
                结束: (1, 1),
            },
            状态: 分析状态::初始,
            输出: Vec::new(),
            缓存: Vec::new(),
        }
    }

    /// 重置缓存的字符为空, 返回缓存的字符组成的字符串
    fn 重置缓存(&mut self) -> String {
        let 结果: String = self.缓存.iter().collect();
        self.缓存.truncate(0);
        结果
    }

    /// 更新源代码位置
    fn 换行(&mut self) {
        // 行号 + 1
        self.位置.开始.0 += 1;
        // 列号 = 1
        self.位置.开始.1 = 1;
        // 更新结束位置
        self.位置.结束 = self.位置.开始;
    }

    /// 更新源代码位置: 将开始位置设为与结束位置相同
    fn 更新开始位置(&mut self) {
        self.位置.开始 = self.位置.结束;
    }

    /// 更新源代码位置: 添加一个字符
    fn 更新结束位置1(&mut self) {
        // 列号 + 1
        self.位置.结束.1 += 1;
    }

    /// 判断当前是否是行首
    fn 位于行首(&self) -> bool {
        // 列号为 1
        1 == self.位置.开始.1
    }

    /// 添加语词后更新内部状态
    fn 语词更新状态(&mut self) {
        self.重置缓存();
        self.状态 = 分析状态::初始;
    }

    /// 添加语词: 换行
    fn 添加语词换行(&mut self) {
        let 词 = 语词 {
            类型: 语词类型::换行,
            位置: self.位置.clone(),
            文本: "".into(),
        };
        self.输出.push(词);
        self.语词更新状态();
        self.换行();
    }

    /// 添加语词: 注释
    fn 添加语词注释(&mut self) {
        let 词 = 语词 {
            类型: 语词类型::注释,
            位置: self.位置.clone(),
            文本: self.重置缓存(),
        };
        self.输出.push(词);
        self.语词更新状态();
        self.更新开始位置();
    }

    /// 添加语词: 缩进
    fn 添加语词缩进(&mut self) -> Result<(), 编译器错误> {
        // 检查缩进长度
        let 缩进长度 = self.缓存.len();
        // 每级缩进强制使用 2 个空格
        if (缩进长度 % 2 != 0) || (缩进长度 > 最大缩进长度) {
            return Err(ne0003(&self.文件, &self.位置, 缩进长度));
        }

        let 词 = 语词 {
            类型: 语词类型::缩进((缩进长度 / 2) as u8),
            位置: self.位置.clone(),
            文本: "".into(),
        };
        self.输出.push(词);
        self.语词更新状态();
        self.更新开始位置();
        Ok(())
    }

    /// 添加语词: 空白
    fn 添加语词空白(&mut self) {
        let 词 = 语词 {
            类型: 语词类型::空白,
            位置: self.位置.clone(),
            文本: "".into(),
        };
        self.输出.push(词);
        self.语词更新状态();
        self.更新开始位置();
    }

    /// 添加语词: 数字
    fn 添加语词数字(&mut self) -> Result<(), 编译器错误> {
        // TODO 检查数字格式

        let 词 = 语词 {
            // TODO
            类型: 语词类型::数字(语法树数字格式::进制10),
            位置: self.位置.clone(),
            文本: self.重置缓存(),
        };
        self.输出.push(词);
        self.语词更新状态();
        self.更新开始位置();
        Ok(())
    }

    /// 添加语词: 文本开始
    fn 添加语词文本开始(&mut self) {
        let 词 = 语词 {
            类型: 语词类型::文本开始,
            位置: self.位置.clone(),
            文本: "".into(),
        };
        self.输出.push(词);
        self.重置缓存();
        self.更新开始位置();
        self.状态 = 分析状态::字符串;
    }

    /// 添加语词: 文本片段
    fn 添加语词文本片段(&mut self) {
        let 词 = 语词 {
            类型: 语词类型::文本片段,
            位置: self.位置.clone(),
            文本: self.重置缓存(),
        };
        self.输出.push(词);
        self.更新开始位置();
    }

    /// 添加语词: 文本结束
    fn 添加语词文本结束(&mut self) {
        let 词 = 语词 {
            类型: 语词类型::文本结束,
            位置: self.位置.clone(),
            文本: "".into(),
        };
        self.输出.push(词);
        self.语词更新状态();
        self.更新开始位置();
    }

    /// 添加简单语词: 只有一个字符组成的
    fn 添加简单语词(&mut self, 类型: 语词类型) {
        let 词 = 语词 {
            类型,
            位置: self.位置.clone(),
            文本: "".into(),
        };
        self.输出.push(词);
        self.语词更新状态();
        self.更新开始位置();
    }

    /// 添加语词: 待分词
    fn 添加语词待分词(&mut self) {
        let 词 = 语词 {
            类型: 语词类型::待分词,
            位置: self.位置.clone(),
            文本: self.重置缓存(),
        };
        self.输出.push(词);
        self.语词更新状态();
        self.更新开始位置();
    }

    /// 添加语词: 已分词
    fn 添加语词已分词(&mut self) {
        let 词 = 语词 {
            类型: 语词类型::已分词,
            位置: self.位置.clone(),
            文本: self.重置缓存(),
        };
        self.输出.push(词);
        self.语词更新状态();
        self.更新开始位置();
    }

    /// 一次喂入一个字符
    pub fn 吃(&mut self, 字符: char) -> Result<(), 编译器错误> {
        let mut 再吃 = false;

        match self.状态 {
            分析状态::初始 => {
                match 字符 {
                    特殊字符换行 => {
                        self.添加语词换行();
                    }
                    特殊字符注释 => {
                        self.状态 = 分析状态::注释;
                    }
                    特殊字符空格 => {
                        if self.位于行首() {
                            // 行首缩进
                            self.状态 = 分析状态::缩进;
                        } else {
                            self.状态 = 分析状态::空白;
                        }
                        再吃 = true;
                    }
                    特殊字符反引号 => {
                        self.状态 = 分析状态::已分词;
                    }
                    特殊字符引号 => {
                        self.添加语词文本开始();
                    }
                    // 简单语词
                    特殊字符小括号左 => {
                        self.添加简单语词(语词类型::小括号左);
                    }
                    特殊字符小括号右 => {
                        self.添加简单语词(语词类型::小括号右);
                    }
                    特殊字符逗号 => {
                        self.添加简单语词(语词类型::逗号);
                    }
                    特殊字符冒号 => {
                        self.添加简单语词(语词类型::冒号);
                    }
                    特殊字符中括号左 => {
                        self.添加简单语词(语词类型::中括号左);
                    }
                    特殊字符中括号右 => {
                        self.添加简单语词(语词类型::中括号右);
                    }
                    特殊字符大括号左 => {
                        self.添加简单语词(语词类型::大括号左);
                    }
                    特殊字符大括号右 => {
                        self.添加简单语词(语词类型::大括号右);
                    }
                    特殊字符顿号 => {
                        self.添加简单语词(语词类型::顿号);
                    }
                    特殊字符句号 => {
                        self.添加简单语词(语词类型::句号);
                    }
                    // 其余字符
                    _ => {
                        // 检查数字
                        if 数字开始字符(字符) {
                            self.状态 = 分析状态::数字;
                        } else {
                            // 普通短语
                            self.状态 = 分析状态::待分词;
                        }
                        再吃 = true;
                    }
                }
            }
            分析状态::注释 => {
                // 注释持续到换行
                if 特殊字符换行 == 字符 {
                    self.添加语词注释();
                    再吃 = true;
                } else {
                    // 保存注释内容
                    self.缓存.push(字符);
                }
            }
            分析状态::空白 => {
                // 空白只能是连续的空格
                if 特殊字符空格 != 字符 {
                    self.添加语词空白();
                    再吃 = true;
                } else {
                    self.缓存.push(字符);
                }
            }
            分析状态::缩进 => {
                // 缩进只能是连续的空格
                if 特殊字符空格 != 字符 {
                    self.添加语词缩进()?;
                    再吃 = true;
                } else {
                    self.缓存.push(字符);
                }
            }
            分析状态::字符串 => {
                match 字符 {
                    // `\n` 错误: 字符串禁止换行
                    特殊字符换行 => {
                        return Err(ne0006(&self.文件, &self.位置));
                    }
                    // `"` 结束字符串
                    特殊字符引号 => {
                        self.添加语词文本片段();
                        self.添加语词文本结束();
                    }
                    // `\\` 转义
                    特殊字符转义 => {
                        self.状态 = 分析状态::字符串转义;
                    }
                    // 保存字符
                    _ => {
                        self.缓存.push(字符);
                    }
                }
            }
            分析状态::字符串转义 => {
                match 字符 {
                    // `\\`
                    特殊字符转义 => {
                        self.缓存.push(特殊字符转义);
                        // 退出转义状态
                        self.状态 = 分析状态::字符串;
                    }
                    // `\n`
                    特殊字符N => {
                        self.缓存.push(特殊字符换行);
                        // 退出转义状态
                        self.状态 = 分析状态::字符串;
                    }
                    // `\(` 开始字符串插值
                    特殊字符小括号左 => {
                        self.添加语词文本片段();
                        self.状态 = 分析状态::字符串插值;
                    }
                    // 错误的转义
                    _ => {
                        return Err(ne0007(&self.文件, &self.位置, 字符));
                    }
                }
            }
            分析状态::字符串插值 => {
                match 字符 {
                    // 禁止使用的字符
                    特殊字符小括号左 | 特殊字符转义 | 特殊字符引号 => {
                        return Err(ne0008(&self.文件, &self.位置, 字符));
                    }
                    // 结束转义
                    特殊字符小括号右 => {
                        // TODO 对字符串插值中复杂表达式的解析
                        self.添加语词待分词();
                        self.状态 = 分析状态::字符串;
                    }
                    // 保存字符
                    _ => {
                        self.缓存.push(字符);
                    }
                }
            }
            分析状态::数字 => {
                if 数字字符(字符) {
                    // 保存数字
                    self.缓存.push(字符);
                } else {
                    // 结束数字
                    self.添加语词数字()?;
                    再吃 = true;
                }
            }
            分析状态::已分词 => {
                match 字符 {
                    // 禁止分词中禁止使用的字符
                    特殊字符换行 | 特殊字符转义 => {
                        return Err(ne0004(&self.文件, &self.位置, 字符));
                    }
                    // 结束当前状态
                    特殊字符反引号 => {
                        self.添加语词已分词();
                    }
                    // 保存字符
                    _ => {
                        self.缓存.push(字符);
                    }
                }
            }
            分析状态::待分词 => {
                match 字符 {
                    // 结束当前状态: 需要特殊处理的字符
                    特殊字符换行
                    | 特殊字符注释
                    | 特殊字符空格
                    | 特殊字符反引号
                    | 特殊字符引号
                    | 特殊字符小括号左
                    | 特殊字符小括号右
                    | 特殊字符中括号左
                    | 特殊字符中括号右
                    | 特殊字符大括号左
                    | 特殊字符大括号右
                    | 特殊字符逗号
                    | 特殊字符冒号
                    | 特殊字符顿号
                    | 特殊字符句号 => {
                        self.添加语词待分词();
                        再吃 = true;
                    }
                    // 保存字符
                    _ => {
                        self.缓存.push(字符);
                    }
                }
            }
        }

        // 检查需要再次处理当前字符
        if 再吃 {
            self.吃(字符)
        } else {
            // 更新结束位置
            if 字符 != 特殊字符换行 {
                self.更新结束位置1();
                if self.状态 == 分析状态::初始 {
                    self.更新开始位置();
                }
            }
            Ok(())
        }
    }

    /// 输出处理结果
    pub fn 结果(self) -> Result<Vec<语词>, 编译器错误> {
        // TODO
        Ok(self.输出)
    }
}

/// 检查是否为数字开始字符
fn 数字开始字符(字符: char) -> bool {
    match 字符 {
        // 数字必须以 0 ~ 9 开头
        特殊字符0..=特殊字符9 => true,
        _ => false,
    }
}

/// 检查是否为数字中允许的字符
fn 数字字符(字符: char) -> bool {
    match 字符 {
        特殊字符0..=特殊字符9
        | 特殊字符A..=特殊字符F
        | 特殊字符_O
        | 特殊字符X
        | 特殊字符点
        | 特殊字符下划线
        | 特殊字符减 => true,
        _ => false,
    }
}
